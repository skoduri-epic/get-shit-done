---
phase: 04-semantic-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/gsd-intel-index.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "Entity files sync to SQLite graph database on write"
    - "Graph persists across hook invocations via graph.db file"
    - "Wiki-links become edges in the graph"
  artifacts:
    - path: "hooks/gsd-intel-index.js"
      provides: "SQLite graph sync on entity write"
      contains: "initSqlJs"
    - path: ".planning/intel/graph.db"
      provides: "Persistent SQLite database"
  key_links:
    - from: "hooks/gsd-intel-index.js"
      to: ".planning/intel/graph.db"
      via: "sql.js export/import"
      pattern: "db\\.export\\(\\)"
---

<objective>
Add SQLite graph layer to the codebase intelligence system using sql.js (WASM).

Purpose: Enable relationship queries ("what uses this file?", "blast radius") by storing entity relationships in a queryable graph database.

Output: Modified gsd-intel-index.js with SQLite sync, updated package.json with sql.js dependency.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-semantic-intelligence/04-RESEARCH.md

Key implementation details from research:
- sql.js is WASM SQLite (zero native deps)
- Schema: nodes table (JSON body with virtual id), edges table (source/target)
- Must export() and persist after every write
- Async init but sync operations
- Use ON CONFLICT REPLACE for upserts

Existing code to modify:
- hooks/gsd-intel-index.js already has: parseEntityFrontmatter(), extractWikiLinks(), regenerateEntitySummary()
- Entity files trigger regenerateEntitySummary() when written
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sql.js dependency and graph schema</name>
  <files>package.json, hooks/gsd-intel-index.js</files>
  <action>
1. Add sql.js dependency to package.json:
   ```json
   "dependencies": {
     "sql.js": "^1.12.0"
   }
   ```

2. At top of hooks/gsd-intel-index.js, add require and schema constant:
   ```javascript
   const initSqlJs = require('sql.js');

   // Graph database schema (simple-graph pattern)
   const GRAPH_SCHEMA = `
   CREATE TABLE IF NOT EXISTS nodes (
     body TEXT,
     id TEXT GENERATED ALWAYS AS (json_extract(body, '$.id')) VIRTUAL NOT NULL UNIQUE
   );
   CREATE INDEX IF NOT EXISTS id_idx ON nodes(id);

   CREATE TABLE IF NOT EXISTS edges (
     source TEXT NOT NULL,
     target TEXT NOT NULL,
     relationship TEXT DEFAULT 'depends_on',
     UNIQUE(source, target, relationship) ON CONFLICT REPLACE
   );
   CREATE INDEX IF NOT EXISTS source_idx ON edges(source);
   CREATE INDEX IF NOT EXISTS target_idx ON edges(target);
   `;
   ```

Note: Intentionally no FOREIGN KEY constraints - entity A can reference entity B before B is indexed. Orphan edges are acceptable.
  </action>
  <verify>
   - `grep -q "sql.js" package.json` returns 0
   - `grep -q "GRAPH_SCHEMA" hooks/gsd-intel-index.js` returns 0
  </verify>
  <done>package.json has sql.js dependency, gsd-intel-index.js has schema constant</done>
</task>

<task type="auto">
  <name>Task 2: Implement graph database helpers</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Add helper functions after the GRAPH_SCHEMA constant:

```javascript
// Singleton SQL instance (async init, reuse across calls)
let sqlInstance = null;

/**
 * Get or initialize sql.js instance
 * Caches the SQL constructor for reuse
 */
async function getSQL() {
  if (!sqlInstance) {
    sqlInstance = await initSqlJs();
  }
  return sqlInstance;
}

/**
 * Load or create the graph database
 * Returns { db, dbPath } for operations and persistence
 */
async function loadGraphDatabase() {
  const SQL = await getSQL();
  const dbPath = path.join(process.cwd(), '.planning', 'intel', 'graph.db');

  let db;
  if (fs.existsSync(dbPath)) {
    const buffer = fs.readFileSync(dbPath);
    db = new SQL.Database(buffer);
  } else {
    db = new SQL.Database();
    db.run(GRAPH_SCHEMA);
  }

  return { db, dbPath };
}

/**
 * Persist database to disk
 * Must call after every write operation
 */
function persistDatabase(db, dbPath) {
  const data = db.export();
  const buffer = Buffer.from(data);
  fs.writeFileSync(dbPath, buffer);
}
```

Key design notes:
- getSQL() caches the WASM instance (expensive to init)
- loadGraphDatabase() handles both create and load
- persistDatabase() called after EVERY write (sql.js is in-memory only)
  </action>
  <verify>`grep -q "loadGraphDatabase" hooks/gsd-intel-index.js` returns 0</verify>
  <done>Graph database helper functions exist in hook</done>
</task>

<task type="auto">
  <name>Task 3: Sync entity to graph on write</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Add syncEntityToGraph() function and integrate with existing entity handling:

```javascript
/**
 * Sync entity file to graph database
 * Called when an entity .md file is written
 *
 * @param {string} entityPath - Path to entity file
 */
async function syncEntityToGraph(entityPath) {
  const intelDir = path.join(process.cwd(), '.planning', 'intel');

  // Opt-in check (same as updateIndex)
  if (!fs.existsSync(intelDir)) {
    return;
  }

  try {
    const { db, dbPath } = await loadGraphDatabase();

    // Read entity file
    const content = fs.readFileSync(entityPath, 'utf8');
    const entityId = path.basename(entityPath, '.md').toLowerCase();
    const frontmatter = parseEntityFrontmatter(content);
    const links = extractWikiLinks(content);

    // Build node JSON
    const nodeBody = JSON.stringify({
      id: entityId,
      path: frontmatter.path || entityPath,
      type: frontmatter.type || 'unknown',
      updated: frontmatter.updated || new Date().toISOString().split('T')[0],
      status: frontmatter.status || 'active'
    });

    // Upsert node (ON CONFLICT handled by schema)
    db.run(
      `INSERT INTO nodes (body) VALUES (?)
       ON CONFLICT(id) DO UPDATE SET body = excluded.body`,
      [nodeBody]
    );

    // Delete old edges for this source, insert new ones
    db.run('DELETE FROM edges WHERE source = ?', [entityId]);

    if (links.length > 0) {
      const stmt = db.prepare('INSERT INTO edges (source, target) VALUES (?, ?)');
      for (const target of links) {
        stmt.run([entityId, target.toLowerCase()]);
      }
      stmt.free();
    }

    // Persist to disk (critical - sql.js is in-memory)
    persistDatabase(db, dbPath);
    db.close();
  } catch (e) {
    // Silent failure - never block Claude
    // Graph sync is best-effort enhancement
  }
}
```

Then modify the entity file handling in the stdin handler:

Find this section:
```javascript
// Handle entity file writes - regenerate summary
if (isEntityFile(filePath)) {
  regenerateEntitySummary();
  process.exit(0);
}
```

Change to:
```javascript
// Handle entity file writes - sync to graph, regenerate summary
if (isEntityFile(filePath)) {
  syncEntityToGraph(filePath).then(() => {
    regenerateEntitySummary();
    process.exit(0);
  }).catch(() => {
    // Silent failure
    process.exit(0);
  });
  return; // Don't exit synchronously, wait for async
}
```

Note the return statement - we need to wait for async graph sync before exiting.
  </action>
  <verify>
Run manual test:
```bash
cd /Users/lexchristopherson/Developer/claude-code-resources/get-shit-done
mkdir -p .planning/intel/entities
echo '---
path: /test/example.ts
type: util
updated: 2026-01-20
status: active
---

# example.ts

## Purpose
Test file for graph sync.

## Dependencies
- [[src-lib-db]]

## Used By
TBD
' > .planning/intel/entities/test-example.md

# Simulate hook execution
echo '{"tool_name":"Write","tool_input":{"file_path":".planning/intel/entities/test-example.md"}}' | node hooks/gsd-intel-index.js

# Check graph.db was created
ls -la .planning/intel/graph.db

# Cleanup
rm .planning/intel/entities/test-example.md
rm .planning/intel/graph.db 2>/dev/null
```
  </verify>
  <done>Entity writes sync to SQLite graph database, graph.db persists across invocations</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Dependency installed:
   ```bash
   grep -q '"sql.js"' package.json && echo "PASS: sql.js in package.json"
   ```

2. Schema and helpers exist:
   ```bash
   grep -q "GRAPH_SCHEMA" hooks/gsd-intel-index.js && echo "PASS: Schema defined"
   grep -q "loadGraphDatabase" hooks/gsd-intel-index.js && echo "PASS: Helpers exist"
   ```

3. Graph sync works:
   - Create test entity file with [[wiki-link]]
   - Simulate Write hook
   - Verify graph.db created
   - Verify node and edge inserted (use sqlite3 CLI if available, or just check file size > 0)
</verification>

<success_criteria>
- [ ] sql.js added to package.json dependencies
- [ ] GRAPH_SCHEMA constant defines nodes and edges tables
- [ ] loadGraphDatabase() handles create and load
- [ ] persistDatabase() saves after writes
- [ ] syncEntityToGraph() upserts nodes and edges
- [ ] Entity file writes trigger graph sync before summary regeneration
- [ ] Silent failures don't block Claude
</success_criteria>

<output>
After completion, create `.planning/phases/04-semantic-intelligence/04-01-SUMMARY.md`
</output>
