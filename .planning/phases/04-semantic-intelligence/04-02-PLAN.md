---
phase: 04-semantic-intelligence
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - hooks/gsd-intel-index.js
autonomous: true

must_haves:
  truths:
    - "Summary includes dependency hotspots queried from SQLite"
    - "Summary shows file purposes, not just file counts"
    - "Transitive dependents queryable via recursive CTE"
    - "SessionStart hook injects graph-backed summary into context"
  artifacts:
    - path: "hooks/gsd-intel-index.js"
      provides: "Graph-backed summary generation"
      contains: "generateGraphSummary"
    - path: ".planning/intel/summary.md"
      provides: "Rich semantic summary for context injection"
  key_links:
    - from: "hooks/gsd-intel-index.js"
      to: ".planning/intel/graph.db"
      via: "SQL queries for hotspots"
      pattern: "SELECT.*FROM edges.*GROUP BY"
    - from: "hooks/gsd-intel-session.js"
      to: ".planning/intel/summary.md"
      via: "fs.readFileSync on startup/resume"
      pattern: "readFileSync.*summary\\.md"
---

<objective>
Generate rich summaries from SQLite graph instead of simple file counts.

Purpose: Provide Claude with actionable intelligence - dependency hotspots, file purposes, and relationship awareness at session start.

Output: Updated gsd-intel-index.js with graph-backed summary generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-semantic-intelligence/04-RESEARCH.md
@.planning/phases/04-semantic-intelligence/04-01-SUMMARY.md

From 04-01: SQLite graph layer with nodes (entity metadata) and edges (wiki-links).

Summary generation requirements (from research):
- Query hotspots: most-depended-on files
- Group by type from node body
- Include file purposes from entity content
- Target < 500 tokens for context injection

Existing wiring (from Phase 2):
- hooks/gsd-intel-session.js reads summary.md on startup/resume
- Injects content as <codebase-intelligence> tag into Claude's context
- This wiring already exists - we verify it works with new graph format
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add graph query helpers</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Add graph query functions after the existing graph helpers (loadGraphDatabase, persistDatabase):

```javascript
/**
 * Get dependency hotspots from graph
 * Returns top N files by number of dependents
 *
 * @param {object} db - sql.js database instance
 * @param {number} limit - Max results (default 5)
 * @returns {Array<{id: string, count: number, path: string, type: string}>}
 */
function getHotspots(db, limit = 5) {
  const results = db.exec(`
    SELECT
      e.target as id,
      COUNT(*) as count,
      json_extract(n.body, '$.path') as path,
      json_extract(n.body, '$.type') as type
    FROM edges e
    LEFT JOIN nodes n ON e.target = n.id
    GROUP BY e.target
    ORDER BY count DESC
    LIMIT ?
  `, [limit]);

  if (!results[0]?.values) return [];

  return results[0].values.map(([id, count, path, type]) => ({
    id,
    count,
    path: path || id,
    type: type || 'unknown'
  }));
}

/**
 * Get nodes grouped by type
 * Returns type -> count mapping
 *
 * @param {object} db - sql.js database instance
 * @returns {Array<{type: string, count: number}>}
 */
function getNodesByType(db) {
  const results = db.exec(`
    SELECT
      json_extract(body, '$.type') as type,
      COUNT(*) as count
    FROM nodes
    GROUP BY type
    ORDER BY count DESC
  `);

  if (!results[0]?.values) return [];

  return results[0].values.map(([type, count]) => ({
    type: type || 'other',
    count
  }));
}

/**
 * Get all dependents of a file (transitive)
 * Uses recursive CTE for graph traversal
 *
 * @param {object} db - sql.js database instance
 * @param {string} entityId - Starting entity
 * @param {number} maxDepth - Max recursion depth (default 5)
 * @returns {Array<{id: string, depth: number, path: string}>}
 */
function getDependents(db, entityId, maxDepth = 5) {
  const results = db.exec(`
    WITH RECURSIVE dependents(id, depth) AS (
      SELECT ?, 0
      UNION
      SELECT e.source, d.depth + 1
      FROM edges e
      JOIN dependents d ON e.target = d.id
      WHERE d.depth < ?
    )
    SELECT DISTINCT
      d.id,
      d.depth,
      json_extract(n.body, '$.path') as path
    FROM dependents d
    LEFT JOIN nodes n ON d.id = n.id
    WHERE d.id != ?
    ORDER BY d.depth, d.id
  `, [entityId.toLowerCase(), maxDepth, entityId.toLowerCase()]);

  if (!results[0]?.values) return [];

  return results[0].values.map(([id, depth, path]) => ({
    id,
    depth,
    path: path || id
  }));
}
```

Key design notes:
- LEFT JOIN on nodes allows edges to exist even if target node doesn't exist yet
- UNION (not UNION ALL) prevents infinite loops in cyclic graphs
- maxDepth limit prevents runaway queries
- All IDs lowercased for consistency
  </action>
  <verify>`grep -q "getHotspots" hooks/gsd-intel-index.js && grep -q "getDependents" hooks/gsd-intel-index.js`</verify>
  <done>Graph query helpers exist: getHotspots, getNodesByType, getDependents</done>
</task>

<task type="auto">
  <name>Task 2: Create graph-backed summary generator</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Add generateGraphSummary() function that queries the graph database:

```javascript
/**
 * Generate semantic summary from graph database
 * Called when graph.db exists (Phase 4+)
 * Falls back to entity-based summary if no graph
 *
 * Target: < 500 tokens for context injection
 */
async function generateGraphSummary() {
  const intelDir = path.join(process.cwd(), '.planning', 'intel');
  const dbPath = path.join(intelDir, 'graph.db');
  const summaryPath = path.join(intelDir, 'summary.md');
  const entitiesDir = path.join(intelDir, 'entities');

  // Require graph.db to exist
  if (!fs.existsSync(dbPath)) {
    return null; // Caller should fall back to entity summary
  }

  try {
    const { db } = await loadGraphDatabase();

    const lines = [];

    // Header
    lines.push('# Codebase Intelligence');
    lines.push('');

    // File count from nodes
    const countResult = db.exec('SELECT COUNT(*) FROM nodes');
    const fileCount = countResult[0]?.values[0]?.[0] || 0;
    lines.push(`**Indexed entities:** ${fileCount}`);
    lines.push(`**Last updated:** ${new Date().toISOString().split('T')[0]}`);
    lines.push('');

    // Dependency hotspots (most impactful files)
    const hotspots = getHotspots(db, 5);
    if (hotspots.length > 0) {
      lines.push('## Dependency Hotspots');
      lines.push('');
      lines.push('Files with most dependents (change carefully):');
      for (const { path: filePath, count, type } of hotspots) {
        const typeLabel = type !== 'unknown' ? ` [${type}]` : '';
        lines.push(`1. \`${filePath}\` (${count} dependents)${typeLabel}`);
      }
      lines.push('');
    }

    // Group by type
    const byType = getNodesByType(db);
    if (byType.length > 0) {
      lines.push('## Module Types');
      lines.push('');
      for (const { type, count } of byType) {
        const label = type.charAt(0).toUpperCase() + type.slice(1);
        lines.push(`- **${label}**: ${count} files`);
      }
      lines.push('');
    }

    // Edge count (relationship density)
    const edgeResult = db.exec('SELECT COUNT(*) FROM edges');
    const edgeCount = edgeResult[0]?.values[0]?.[0] || 0;
    if (edgeCount > 0) {
      lines.push(`**Relationships tracked:** ${edgeCount}`);
      lines.push('');
    }

    db.close();

    // Write summary
    const summary = lines.join('\n');
    fs.writeFileSync(summaryPath, summary);

    return summary;
  } catch (e) {
    // Graph query failed, return null to fall back
    return null;
  }
}
```

Key design notes:
- Returns null if graph doesn't exist or query fails (allows fallback)
- Hotspots show files that cause most downstream impact
- Module types provide quick orientation
- Edge count indicates relationship density
- Targets < 500 tokens (no verbose lists)
  </action>
  <verify>`grep -q "generateGraphSummary" hooks/gsd-intel-index.js`</verify>
  <done>generateGraphSummary() function queries graph and writes summary.md</done>
</task>

<task type="auto">
  <name>Task 3: Integrate graph summary into regeneration flow and verify SessionStart wiring</name>
  <files>hooks/gsd-intel-index.js</files>
  <action>
Modify regenerateEntitySummary() to prefer graph summary when available.

Find the existing regenerateEntitySummary() function and update it:

```javascript
/**
 * Regenerate summary.md from all entity files
 * Uses graph database if available (Phase 4+), falls back to file-based
 */
async function regenerateEntitySummary() {
  const intelDir = path.join(process.cwd(), '.planning', 'intel');
  const entitiesDir = path.join(intelDir, 'entities');
  const summaryPath = path.join(intelDir, 'summary.md');
  const dbPath = path.join(intelDir, 'graph.db');

  // Check directories exist
  if (!fs.existsSync(entitiesDir)) {
    return;
  }

  // Try graph-based summary first (Phase 4+)
  if (fs.existsSync(dbPath)) {
    try {
      const graphSummary = await generateGraphSummary();
      if (graphSummary) {
        return; // Graph summary written, done
      }
    } catch (e) {
      // Fall through to file-based summary
    }
  }

  // Fall back to existing file-based entity summary
  // (Keep all existing regenerateEntitySummary logic here)
```

The key change: Check for graph.db first, try generateGraphSummary(), only fall back to existing logic if graph unavailable or fails.

Also update the stdin handler to use async regenerateEntitySummary:

Find:
```javascript
if (isEntityFile(filePath)) {
  syncEntityToGraph(filePath).then(() => {
    regenerateEntitySummary();
    process.exit(0);
  })
```

Change to:
```javascript
if (isEntityFile(filePath)) {
  syncEntityToGraph(filePath).then(async () => {
    await regenerateEntitySummary();
    process.exit(0);
  })
```

Note: regenerateEntitySummary becomes async because it calls generateGraphSummary.
  </action>
  <verify>
Test the full flow including SessionStart injection:
```bash
cd /Users/lexchristopherson/Developer/claude-code-resources/get-shit-done

# Create test entities with dependencies
mkdir -p .planning/intel/entities

echo '---
path: /test/db.ts
type: util
updated: 2026-01-20
status: active
---
# db.ts
## Purpose
Database client.
## Dependencies
None
## Used By
TBD
' > .planning/intel/entities/test-db.md

echo '---
path: /test/auth.ts
type: util
updated: 2026-01-20
status: active
---
# auth.ts
## Purpose
Auth utilities.
## Dependencies
- [[test-db]]
## Used By
TBD
' > .planning/intel/entities/test-auth.md

echo '---
path: /test/api.ts
type: api
updated: 2026-01-20
status: active
---
# api.ts
## Purpose
API routes.
## Dependencies
- [[test-db]]
- [[test-auth]]
## Used By
TBD
' > .planning/intel/entities/test-api.md

# Sync all to graph
for f in .planning/intel/entities/test-*.md; do
  echo "{\"tool_name\":\"Write\",\"tool_input\":{\"file_path\":\"$f\"}}" | node hooks/gsd-intel-index.js
done

# Check summary.md has graph-based content
cat .planning/intel/summary.md
# Should show:
# - "Dependency Hotspots" section
# - test-db with 2 dependents (auth and api both depend on it)

# Verify SessionStart hook reads new summary format
echo '{"source":"startup"}' | node hooks/gsd-intel-session.js
# Should output <codebase-intelligence>...</codebase-intelligence> with hotspots

# Cleanup
rm .planning/intel/entities/test-*.md
rm .planning/intel/graph.db
rm .planning/intel/summary.md
```
  </verify>
  <done>Summary generation prefers graph when available, SessionStart hook confirmed to inject graph-backed summary</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Query helpers exist:
   ```bash
   grep -q "getHotspots" hooks/gsd-intel-index.js && echo "PASS"
   grep -q "getDependents" hooks/gsd-intel-index.js && echo "PASS"
   ```

2. Graph summary generator exists:
   ```bash
   grep -q "generateGraphSummary" hooks/gsd-intel-index.js && echo "PASS"
   ```

3. Summary prefers graph:
   - Create entities with [[wiki-links]]
   - Simulate entity writes
   - Check summary.md has "Dependency Hotspots" section
   - Hotspot counts are accurate

4. SessionStart wiring verified:
   ```bash
   # Verify SessionStart reads and injects the new format
   echo '{"source":"startup"}' | node hooks/gsd-intel-session.js | grep -q "Dependency Hotspots" && echo "PASS: SessionStart injects graph summary"
   ```
</verification>

<success_criteria>
- [ ] getHotspots() queries top N most-depended files
- [ ] getNodesByType() groups entities by type
- [ ] getDependents() uses recursive CTE for transitive queries
- [ ] generateGraphSummary() produces < 500 token summary
- [ ] regenerateEntitySummary() prefers graph when graph.db exists
- [ ] Falls back gracefully to file-based summary
- [ ] Summary includes dependency hotspots with accurate counts
- [ ] SessionStart hook (gsd-intel-session.js) correctly injects graph-backed summary into context
</success_criteria>

<output>
After completion, create `.planning/phases/04-semantic-intelligence/04-02-SUMMARY.md`
</output>
